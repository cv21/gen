package mock

import (
	"encoding/json"
	"fmt"

	"github.com/cv21/gen/pkg"
	. "github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/vetcher/go-astra/types"
)

const (
	mockPackage = "github.com/stretchr/testify/mock"

	// It is a name of current generator.
	// Useful for package comments.
	generatorName = "mock"
)

type (
	// It is custom parameters for mock generator.
	GeneratorParams struct {
		InterfaceName string `json:"interface_name"`
		OutPath       string `json:"out_path"`
		PackageName   string `json:"package_name"`
	}

	mockGenerator struct {
	}
)

// Implements Generator interface.
// Generates mock files.
func (m *mockGenerator) Generate(p *pkg.GenerateParams) (*pkg.GenerateResult, error) {
	params := &GeneratorParams{}
	err := json.Unmarshal(p.Params, params)
	if err != nil {
		return nil, err
	}

	iface := pkg.FindInterface(p.File, params.InterfaceName)

	f := NewFile(params.PackageName)

	mockStructName := m.buildMockStructName(iface.Name)

	f.Add(m.generateType(mockStructName, iface.Name)).Line()

	for _, method := range iface.Methods {
		f.Add(m.generateMethod(iface.Name, mockStructName, method)).Line()
	}

	return &pkg.GenerateResult{
		Files: []pkg.GenerateResultFile{
			{
				Path:    fmt.Sprintf(params.OutPath, strcase.ToSnake(iface.Name)),
				Content: []byte(fmt.Sprintf("%#v", pkg.AddDefaultPackageComment(f, generatorName))),
			},
		},
	}, nil
}

// Generates type declaration. For example:
//
// // StringServiceMock is an autogenerated mock type for the StringService interface.
// type StringServiceMock struct {
// 		mock.Mock
// }
func (m *mockGenerator) generateType(mockStructName, interfaceName string) *Statement {
	return Commentf("%s is an autogenerated mock type for the %s interface.", mockStructName, interfaceName).Line().
		Type().Id(mockStructName).Struct(
		Qual(mockPackage, "Mock"),
	)
}

// Generates method declaration. For example:
//
// // Concat provides a mock function for method Concat of interface StringService.
// func (_m *StringServiceMock) Concat(a string, b string) string {
//		ret := _m.Called(a, b)
//
//		var r0 string
//		if rf, ok := ret.Get(0).(func(string, string) string); ok {
//			r0 = rf(a, b)
//		} else {
//			r0 = ret.Get(0).(string)
//		}
//
//		return r0
// }
//
func (m *mockGenerator) generateMethod(interfaceName, mockStructName string, method *types.Function) *Statement {
	return Commentf("%s provides a mock function for method %s of interface %s.", method.Name, method.Name, interfaceName).Line().
		Func().Params(Id("_m").Id(fmt.Sprintf("*%s", mockStructName))).Id(method.Name).ParamsFunc(func(g *Group) {
		for _, a := range method.Args {
			g.Id(a.Name).Add(pkg.TypeQual(a.Type))
		}
	}).ParamsFunc(func(g *Group) {
		for _, r := range method.Results {
			g.Id(r.Name).Add(pkg.TypeQual(r.Type))
		}
	}).BlockFunc(func(g *Group) {
		g.Id("ret").Op(":=").Id("_m.Called").ParamsFunc(func(g *Group) {
			for _, a := range method.Args {
				g.Id(a.Name)
			}
		}).Line()

		var retNames []string
		for i, r := range method.Results {
			currentRetName := fmt.Sprintf("r%d", i)
			retNames = append(retNames, currentRetName)

			g.Var().Id(currentRetName).Add(pkg.TypeQual(r.Type))
			g.If(List(Id("rf"), Id("ok").Op(":=").Id("ret.Get").Call(Lit(i))).Assert(Func().ParamsFunc(func(g *Group) {
				for _, a := range method.Args {
					g.Id(a.Type.String())
				}
			}).Add(pkg.TypeQual(r.Type))), Id("ok")).BlockFunc(func(g *Group) {
				g.Id(currentRetName).Op("=").Id("rf").ParamsFunc(func(g *Group) {
					for _, a := range method.Args {
						g.Id(a.Name)
					}
				})
			}).Else().BlockFunc(func(g *Group) {
				g.Id(currentRetName).Op("=").Id("ret.Get").Params(Lit(i)).Assert(pkg.TypeQual(r.Type))
			}).Line()
		}

		g.ReturnFunc(func(g *Group) {
			for _, retName := range retNames {
				g.Add(Id(retName))
			}
		})
	})
}

// Returns a mock structure name by given interfaceName.
func (m *mockGenerator) buildMockStructName(interfaceName string) string {
	return fmt.Sprintf("%sMock", interfaceName)
}

// Allocates and returns new structure of mockGenerator.
func NewMockGenerator() pkg.Generator {
	return &mockGenerator{}
}
